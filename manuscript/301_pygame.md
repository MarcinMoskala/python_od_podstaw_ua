# Дай мені вікно у&nbsp;світ

> У цьому розділі ми&nbsp;встановимо пакет PyGame і використаємо його для малювання елементів нашої гри.

Настав час&nbsp;застосувати те, чого ми&nbsp;навчилися, на&nbsp;практиці: ми&nbsp;напишемо гру&nbsp;"Змійка" (англ. Snake). Правила прості: гравець водить "змійку" по&nbsp;екрану. Його завдання — направляти її&nbsp;до кульок "їжі". Коли "змія" з’їдає "їжу", вона росте. Гравець програє, коли "змійка" стикається з&nbsp;власним хвостом.

{width: 80%}
![Так виглядатиме наша гра.](301_snake.png)

Ти вже маєш більшість навичок, необхідних для написання такої гри. Єдине, чого Тобі не&nbsp;вистачає, це&nbsp;знання того, як&nbsp;відображати елементи перегляду та&nbsp;як&nbsp;прописати реакцію інтерфейсу на&nbsp;натискання кнопок гравцем. Решта — це&nbsp;практичне застосування того, що&nbsp;Тобі вдалося дізнатися з&nbsp;попередніх розділів.

## Як працюють ігри?

Якщо спростити, графіка в&nbsp;іграх зводиться до того, що&nbsp;в області, де&nbsp;вона відображається, промальовуються зображення, подібно до фільмів, де&nbsp;сцени — це&nbsp;швидка зміна кадрів, такі собі "рухомі картинки". Щоб&nbsp;створити враження руху, малюнки відображаються послідовно на&nbsp;почергових етапах руху. До&nbsp;цього додається зсув. Наприклад, якщо персонаж рухається праворуч, кожне наступне його зображення має бути намальоване трохи правіше від попереднього. Також потрібно стерти попереднє зображення, щоб після нього не&nbsp;залишилося жодного сліду. Таким чином відповідна кількість зображень, які швидко відтворюються, створює ілюзію плавного руху персонажа.

![Персонаж гри кадр за кадром.](301_game.jpg)

У нашому випадку ми&nbsp;не займатимемося анімуванням персонажа, натомість відображатимемо "змійку" та&nbsp;її&nbsp;"їжу".

## Встановлення PyGame

Встановлення пакетів ми&nbsp;розглядали у&nbsp;розділі *Встановлення пакетів*. Зараз нам потрібно встановити `pygame`. Якщо Ти&nbsp;користуєшся `pip`, введи в&nbsp;командному рядку:

```
python -m pip install -U pygame --user
```

У налаштуваннях PyCharm ми&nbsp;можемо запустити вікно керування пакетами і там за допомогою плюса додати `pygame`.

![Керування встановленими пакетами в&nbsp;PyCharm. Щоб&nbsp;додати новий пакет, натисни плюс, і відкриється вікно пошуку пакетів.](301_PyCharm_pygame.png)

## Створімо вікно у&nbsp;світ

Тепер, коли у&nbsp;нас є пакет PyGame, створімо файл, у&nbsp;якому ми&nbsp;будемо ним користуватися. Ми&nbsp;можемо його назвати `game.py`. Імпорт PyGame виглядає, як&nbsp;більшість пакетів, це&nbsp;просто команда `import pygame`. Потім ми&nbsp;повинні викликати функцію `init()`, яка ініціалізує всі модулі пакета. Небагато пакетів мають подібні вимоги, але PyGame має багато функцій, тож деякі з&nbsp;них потрібно ініціалізувати.

```python
# game.py
import pygame

pygame.init()
```

Наступним кроком є налаштування вікна, в&nbsp;якому буде відображатися наша гра. Для цього ми&nbsp;використовуємо функцію `pygame.display.set_mode`, якій ми&nbsp;передаємо тапл із розміром вікна. Вікно має висоту і ширину, тому тапл повинен мати два значення типу `int`. Якого розміру має бути це&nbsp;вікно? Припустімо, наше поле матиме розмір 20 на&nbsp;20, а кожен фрагмент матиме розмір 25 [^301_1]. Тому вікно має мати висоту і ширину `20 * 25`. Оскільки ми&nbsp;малюємо квадрати, то їхню висоту і ширину будемо визначати однаковими координатами `WIDTH`.

```python
CUBE_SIZE = 25
CUBES_NUM = 20
WIDTH = CUBE_SIZE * CUBES_NUM
screen = pygame.display.set_mode((WIDTH, WIDTH))
```

> Постійні (тобто незмінні) значення, такі як&nbsp;`CUBE_SIZE`, `CUBES_NUM` або `WIDTH`, ми&nbsp;зазвичай записуємо великими літерами, згідно з&nbsp;конвенцією SCREAMING_SNAKE_CASE.

{width: 80%}
![](SCREAMING_SNAKE_CASE.png)

Наступний крок — установлення білого кольору вікна. Для цього ми&nbsp;використаємо функцію `fill` з&nbsp;посиланням на&nbsp;вікно. Як значення ми&nbsp;знову повинні передати тапл, у&nbsp;якому буде збережено колір за допомогою запису RGB.

{width: 80%}
![](301_color_picker.png)

RGB — це&nbsp;одна із основних систем позначень кольорів. Послідовні числа представляють значення червоного, зеленого та&nbsp;синього кольору (звідси назва: **R**ed, **G**reen, **B**lue). Базові кольори змішуються між собою, і в&nbsp;результаті утворюються інші барви. Щоб&nbsp;зрозуміти, як&nbsp;з&nbsp;них утворюються кольори, уяви три проєктори, які світять червоним, зеленим та&nbsp;синім. Там, куди не&nbsp;потрапляє жоден промінь, буде абсолютно темно. Там, де&nbsp;всі вони світять із максимальною потужністю, буде біле світло. Там, де&nbsp;перетинатимуться червоний і зелений, ми&nbsp;побачимо жовтий. Регулюючи інтенсивність усіх трьох проєкторів, ми&nbsp;можемо отримати практично будь-який колір.

{width: 60%}
![](301_RGB_illumination.jpeg)

Оскільки максимальне значення становить `255`, білий колір створюється через `(255, 255, 255)`.

```python
WHITE = (255, 255, 255)
screen.fill(WHITE)
```

Додаймо до нашої гри кілька корисних кольорів:

```python
BLUE = (0, 0, 255)
GREEN = (0, 255, 0)
WHITE = (255, 255, 255)
```

Після кожної зміни виду ми&nbsp;повинні викликати `pygame.display.update()`, щоб пакет знав, що&nbsp;потрібно відобразити зміну.

```python
pygame.display.update()
```

Якби ми&nbsp;запустили гру&nbsp;зараз, вікно б з’явилося і негайно закрилося. Тобто наша програма закінчилася б і припинила роботу. Так працюють програми: коли ми&nbsp;підходимо до кінця сценарію, їхнє виконання припиняється. Як цьому протидіяти? Найпростіший спосіб — за допомогою циклу while. Для початку ми&nbsp;можемо використати нескінченний цикл:

```python
while True:
    pass
```

Коли ми&nbsp;запустимо цю програму, то нарешті побачимо вікно з&nbsp;білим фоном. Тепер програма працюватиме, доки триває гра. На жаль, виникає протилежна проблема: коли хтось закриє вікно, програма далі працюватиме. Цю проблему можна вирішити різними способами. Часто цикли while ставлять у&nbsp;залежність від змінної, яка сигналізує, чи програма досі повинна працювати. Однак більш надійний метод — це&nbsp;виклик функції `quit()`, яка негайно завершує програму. Ми&nbsp;повинні викликати її, коли користувач просить закрити гру, а отже, у&nbsp;відповідь на&nbsp;певну подію. Ми&nbsp;ще поговоримо про події пізніше, а поки що&nbsp;достатньо зазначити, що&nbsp;в тіло нашого нескінченного циклу ми&nbsp;повинні додати такий код:

```python
for event in pygame.event.get():
    if event.type == pygame.QUIT:
        quit()
```

Код на&nbsp;цьому етапі має виглядати так:

```python
# game.py
import pygame

pygame.init()

CUBE_SIZE = 25
CUBES_NUM = 20
WIDTH = CUBE_SIZE * CUBES_NUM
screen = pygame.display.set_mode((WIDTH, WIDTH))
WHITE = (255, 255, 255)
screen.fill(WHITE)
pygame.display.update()

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            quit()
```

Коли ми&nbsp;його запустимо, то побачимо біле вікно. В ньому буде наша гра. Коли ми&nbsp;закриємо це&nbsp;вікно, наша програма також завершиться.

{width: 60%}
![](301_empty_window.png)

Це дуже гарний початок нашої пригоди. Тепер поговорімо про малювання "змійки" та&nbsp;її "їжі".

## Квадрат

Щоб намалювати квадрат у&nbsp;PyGame, ми&nbsp;використовуємо `pygame.draw.rect` з&nbsp;аргументами:

* посилання на&nbsp;вікно, тобто `screen`;
* колір (тапл RGB);
* тапли з&nbsp;координатами лівого верхнього кута та&nbsp;розміром квадрата.

{width: 80%}
![Визначення координат точки.](301_coordinates.jpg)

{width: 80%}
![Квадрати розміром 25 на&nbsp;25 із координатами (25, 25) і (175, 75).](301_cubes.jpg)

У нашому випадку квадрати будуть використані для малювання "змійки". Можемо використати зелений колір `(0, 255, 0)`. Ми&nbsp;визначили його висоту і ширину як&nbsp;`CUBE_SIZE`. Що стосується розміщення, то фрагменти повинні перебувати на&nbsp;сітці розміром `CUBES_NUM`. Тому ми&nbsp;б віддали перевагу визначенню розташування фрагмента за координатами на&nbsp;цій сітці. Таке розташування можна визначати за двома параметрами `x` та&nbsp;`y`.

```python
def draw_snake_part(x, y):
    position = (x * CUBE_SIZE,
                y * CUBE_SIZE,
                CUBE_SIZE,
                CUBE_SIZE)
    pygame.draw.rect(screen, GREEN, position)
    pygame.display.update()
```

{width: 100%}
![](301_cubes_with_size.jpg)

Використаймо цю функцію, щоб намалювати кілька частин "змійки" в&nbsp;різних місцях:

```python
draw_snake_part(0, 0)
draw_snake_part(13, 16)
draw_snake_part(10, 10)
draw_snake_part(12, 8)
draw_snake_part(19, 19)
```

{width: 50%}
![](301_squares.png)

## Малювання кола

Малювання кола дуже схоже на&nbsp;малювання квадрата. Для цього ми&nbsp;використовуємо функцію `pygame.draw.circle`, до якої додаємо по&nbsp;черзі:

* посилання на&nbsp;вікно, тобто у&nbsp;нас `screen`;
* колір (тапл RGB);
* положення центру кола (тапл з&nbsp;координатами);
* розмір кола (радіус).

Оскільки ми&nbsp;хочемо, щоб наше коло ідеально вписувалося в&nbsp;квадрати, його радіус повинен дорівнювати рівно половині `CUBE_SIZE`. Оскільки ми&nbsp;визначаємо положення центру кола, його також слід змістити на&nbsp;половину `CUBE_SIZE` відносно положення, де&nbsp;починався би квадрат.

{width: 80%}
![Cітка координат на&nbsp;полотні.](301_circle.jpg)

```python
def draw_food(x, y):
    radius = float(CUBE_SIZE) / 2
    position = (x * CUBE_SIZE + radius,
                y * CUBE_SIZE + radius)
    pygame.draw.circle(screen, BLUE, position, radius)
    pygame.display.update()
```

Скористаймося цією функцією, щоб намалювати кружечки "їжі" в&nbsp;різних місцях нашого поля:

```python
draw_food(0, 0)
draw_food(13, 16)
draw_food(10, 10)
draw_food(12, 8)
draw_food(19, 19)
```

{width: 70%}
![](301_circles.png)

## Малювання "змійки"

Ми можемо подати "змійку" просто як&nbsp;список її&nbsp;елементів. Елементи повністю представлені їхнім розташуванням. Ми&nbsp;могли б створити список таплів, але нам зручніше визначити клас для представлення координат точки. Тут ми&nbsp;можемо згадати клас `Position` із розділу *Оператори*. У нашому прикладі ми&nbsp;будемо використовувати варіант, де&nbsp;він зберігає координати точки, а також дозволяє порівнювати значення і заміняти об’єкт на&nbsp;рядок. Порівняння точок знадобиться для перевірки, чи не&nbsp;наступили ми&nbsp;на хвіст чи "їжу". Їх виписування стане нам в&nbsp;нагоді під час&nbsp;роботи над грою. Додай наступний клас до свого проєкту в&nbsp;окремому файлі під назвою `position.py`.

```python
# position.py
class Position:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return isinstance(other, Position) and \
               self.x == other.x and \
               self.y == other.y

    def __str__(self):
        return f"({self.x}, {self.y})"

    __repr__ = __str__
```

Не забудь імпортувати цей клас у&nbsp;файл гри:

```python
from position import Position
```

Як координати ми&nbsp;будемо вводити номер квадрата по&nbsp;горизонтальній або вертикальній осі. Якщо розмір нашого поля 20, то позиція описується числами від 0 до 19. "Змійка" може виглядати, наприклад, так:

```python
snake = [
    Position(2, 2),
    Position(3, 2),
    Position(4, 2),
    Position(5, 2),
    Position(5, 1),
]
```

![](301_snake_with_positions.jpg)

Тепер відображення "змійки" — це&nbsp;просто відображення її&nbsp;послідовних частин. Для цього ми&nbsp;можемо використати цикл for:

```python
def draw_snake(snake):
    for part in snake:
        draw_snake_part(part.x, part.y)
```

Місце, де&nbsp;міститься "їжа", також буде зручно представляти за допомогою класу `Position`:

```python
food = Position(11, 14)
```

Тож я перероблю функції для малювання клітинок "змійки" та&nbsp;"їжі" так, щоб вони приймали `Position` як&nbsp;аргументи:

```python
def draw_snake_part(pos):
    position = (pos.x * CUBE_SIZE,
                pos.y * CUBE_SIZE,
                CUBE_SIZE,
                CUBE_SIZE)
    pygame.draw.rect(screen, GREEN, position)
    pygame.display.update()

```

```python
def draw_food(pos):
    radius = float(CUBE_SIZE) / 2
    position = (pos.x * CUBE_SIZE + radius,
                pos.y * CUBE_SIZE + radius)
    pygame.draw.circle(screen, BLUE, position, radius)
    pygame.display.update()


def draw_snake(snake):
    for part in snake:
        draw_snake_part(part)
```

## Очищення поля

Щоб малювати на&nbsp;полі, нам потрібна ще тільки одна функція. Перш ніж малювати елементи на&nbsp;новому місці, потрібно стерти елементи, намальовані раніше. Без цього наше поле швидко заповниться застарілими зображеннями. Для очищення поля ми&nbsp;будемо використовувати вже відому нам функцію `fill`, яка заповнює все поле певним кольором.

```python
screen.fill(WHITE)
```

## Оптимізація

Наразі кожна функція, яка вносить зміни до вигляду екрана, викликає функцію `pygame.display.update()`, щоб показати зміну. Однак, коли стан нашої гри почне змінюватися, це&nbsp;може призвести до того, що&nbsp;деякі елементи будуть блимати [^301_2]. Це також не&nbsp;найефективніше рішення, оскільки ми&nbsp;перемальовуємо елементи набагато частіше, ніж потрібно. Було би набагато краще спочатку визначити всі зміни, а потім відобразити їх одночасно. Щоб&nbsp;зробити це, ми&nbsp;позбудемося `update` з&nbsp;окремих функцій, натомість введемо функцію `draw`, яка намалює всі цікаві для нас елементи.

```python
def draw_snake_part(pos):
    position = (pos.x * CUBE_SIZE,
                pos.y * CUBE_SIZE,
                CUBE_SIZE,
                CUBE_SIZE)
    pygame.draw.rect(screen, GREEN, position)


def draw_snake(snake):
    for part in snake:
        draw_snake_part(part)


def draw_food(pos):
    radius = float(CUBE_SIZE) / 2
    position = (pos.x * CUBE_SIZE + radius,
                pos.y * CUBE_SIZE + radius)
    pygame.draw.circle(screen, BLUE, position, radius)


def fill_bg():
    screen.fill(WHITE)


def draw(snake, food):
    fill_bg()
    draw_snake(snake)
    draw_food(food)
    pygame.display.update()
```

[^301_1]: Одиницею вимірювання висоти та&nbsp;ширини в&nbsp;PyGame є пікселі. Звичайно, це&nbsp;небагато говорить про те, що&nbsp;таке 25. Найпростіше підбирати потрібні значення "на око".
[^301_2]: Швидко з’являтися та&nbsp;зникати.

