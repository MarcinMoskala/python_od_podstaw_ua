# Класи та&nbsp;об’єкти

Оскільки ми&nbsp;переходимо до&nbsp;складніших тем, почнімо з&nbsp;ключових понять у&nbsp;мові Python: класи та&nbsp;об’єкти.

Якщо Ти&nbsp;на&nbsp;мить виглянеш за&nbsp;сторінки цієї книги, Ти, ймовірно, побачиш багато об’єктів. Я бачу ноутбук, чашку з&nbsp;кавою, нотатки, планшет для малювання... Наш світ наповнений об’єктами. Так само і в&nbsp;програмуванні — ми&nbsp;оперуємо об’єктами. Деякі з&nbsp;них дуже прості, наприклад рядки або логічні значення. Однак ми&nbsp;можемо визначати власні об’єкти. Це&nbsp;робиться за&nbsp;допомогою класів.

Визначення класів — дуже важливе, оскільки дозволяє нам думати про певні абстракції. В інтернет-магазині — це&nbsp;користувачі, продавці, товари тощо. У грі — гравці, противники та&nbsp;предмети. У медичному застосунку — пацієнти, лікарі, рецепти, направлення. Саме завдяки класам ми&nbsp;можемо виражати такі поняття та&nbsp;оперувати ними. Вони також визначають, як&nbsp;об’єкти всередині класів виглядатимуть і поводитимуться.

Клас — це&nbsp;свого роду шаблон для створення об’єктів. За&nbsp;аналогією, клас — це&nbsp;рецепт, а предмет — приготована страва. Клас визначає, що&nbsp;об’єкт повинен містити і як&nbsp;поводитися.

Почнемо з&nbsp;найпростішого варіанту, яким є порожній клас. Такий клас нічого не&nbsp;міститиме, але матиме назву, завдяки якій ми&nbsp;зможемо створювати об’єкти. Ми&nbsp;створюємо клас словом&nbsp;`class`, після чого вказуємо назву класу, ставимо двокрапку та&nbsp;визначаємо тіло цього класу. Поки що&nbsp;ми&nbsp;визначаємо порожній клас, тому в&nbsp;його тілі ми&nbsp;розмістимо лише&nbsp;`pass`.

Щоб створити за&nbsp;допомогою класу об’єкт, ми&nbsp;використовуємо назву класу та&nbsp;дужки. Це&nbsp;схоже на&nbsp;виклик функції, яка повертає окремий об’єкт. У прикладі нижче на&nbsp;нього буде вказувати змінна&nbsp;`cookie`.

```python
class Cookie:
    pass


cookie = Cookie()
```

![Клас нагадує рецепт страви, а об’єкт — це&nbsp;конкретна порція їжі, приготована за&nbsp;цим рецептом.](class_vs_object.jpg)

На цей момент наш клас порожній, тому об’єкт не&nbsp;дуже цікавий. Так буває далеко не&nbsp;завжди. Об’єкти можуть мати приписані їм&nbsp;змінні та&nbsp;функції. Вони називаються **атрибутами**, а функції в&nbsp;класі називаються **методами**. Незабаром ми&nbsp;про них поговоримо, але поки що&nbsp;почнемо з&nbsp;називання класів.

{width: 60%}
![](201_klasa.png)

## Називання класів

Називаючи класи, ми&nbsp;можемо використовувати ті&nbsp;ж символи, що&nbsp;і для змінних та&nbsp;функцій: малі й великі літери та&nbsp;символ підкреслення&nbsp;`_`. Однак конвенція іменування дещо інша. Для функцій та&nbsp;змінних ми&nbsp;використовували snake_case. У випадку класів ми&nbsp;використовуємо PascalCase (або UpperCamelCase), тобто ми&nbsp;починаємо кожне слово з&nbsp;великої літери, не&nbsp;використовуючи пробіли та&nbsp;підкреслення.

Ось кілька прикладів класів із&nbsp;відповідними іменами:

- `User`;
- `Invoice`;
- `OrderReceipt`;
- `NeuralNetwork`.

### Вправа: Називання класів

Чи правильно названі наступні класи?

- `Personal_Invoice`;
- `UserAddress`;
- `Carengine`;
- `doctor`;
- `Dog`.

Відповіді в&nbsp;кінці книги.

## Об’єктні змінні

Ми можемо призначити об’єкту змінну з&nbsp;певним значенням. Це&nbsp;значення стосуватиметься лише цього одного об’єкта. Щоб&nbsp;посилатися на&nbsp;змінну в&nbsp;об’єкті, ми&nbsp;повинні вказати і об’єкт, і змінну, розділивши їхні назви крапкою. Наприклад, для посилання на&nbsp;змінну&nbsp;`type` в&nbsp;об’єкті&nbsp;`cookie1`, ми&nbsp;використаємо&nbsp;`cookie1.type`. Це&nbsp;застосовується і для присвоєння значення, і для його отримання.

```python
class Cookie:
    pass


cookie1 = Cookie()
cookie2 = Cookie()
cookie1.type = "Dog"
cookie1.breed = "Border Collie"
cookie2.type = "Food"
print(cookie1.type)  # Dog
print(cookie1.breed)  # Border Collie
print(cookie2.type)  # Food
```

Об’єктні змінні рідко створюються поза класом, як&nbsp;у наведеному вище прикладі. Це навіть вважається поганою практикою. Вони частіше створюються у&nbsp;рамках методів, зокрема методу **ініціалізатора**. Ми&nbsp;дійдемо до цього крок за кроком.

### Вправа: Класи і об’єктні змінні

Визнач клас&nbsp;`Player`, який представлятиме гравців гри. Надай йому змінну `points` зі значенням `0`. Виведи кількість балів (має складати `0`), а потім додай один бал до атрибута `points` та&nbsp;виведи кількість балів ще раз (тепер вона має становити `1`).

Відповіді в кінці книги.

## Методи

Усередині класів ми&nbsp;можемо визначати функції. Такі функції називаються **методи**. Ми&nbsp;визначаємо їх у&nbsp;тілі класу, а їхній перший параметр — це&nbsp;посилання на&nbsp;об’єкт, для якого ми&nbsp;будемо викликати цей метод. Цей параметр повинен називатися `self`. Коли ми&nbsp;викликаємо метод, ми&nbsp;починаємо з&nbsp;об’єкта, потім ставимо крапку, назву методу та&nbsp;дужки з&nbsp;аргументами.

```python
class User:
    def cheer(self):
        print(f"Привіт, мене звати {self.name}")

    def say_hello(self, other):
        name=self.name;
        print(f"Привіт, {other}, мене звати {name}")


user = User()
user.name = "Мацєк"
user.cheer()  # Привіт, мене звати Мацєк
user.say_hello("Марта")  
# Привіт, Марта, мене звати Мацєк
```

Об’єкт `self` можна використати також для зміни атрибутів даного об’єкта.

```python
class Position:
    def step_right(self):
        self.x += 1.0

    def move_up(self, value):
        self.y += value


pos = Position()
pos.x = 0.0
pos.y = 0.0
pos.step_right()
print(pos.x)  # 1.0
pos.move_up(6.0)
print(pos.y)  # 6.0
pos.move_up(3.0)
print(pos.y)  # 9.0
```

У наведених вище прикладах ми&nbsp;вказували атрибути об’єкта відразу після його створення. Такий підхід дуже небезпечний, адже користувач, наприклад, може забути визначити один із обов’язкових атрибутів. Натомість буде набагато краще, якщо ми&nbsp;встановимо значення цих атрибутів за допомогою **конструктора**.

## Конструктор та&nbsp;ініціалізатор

При створенні нового об’єкта ми&nbsp;ставимо дужки після назви класу. Ця дужка — це&nbsp;виклик функції, яка формує об’єкт і називається **конструктором**. Ця функція виконує ряд кроків, необхідних для створення об’єкта, включаючи виклик спеціального методу `__init__` [^201_1] з&nbsp;нашого класу. Цей метод називається **ініціалізатором**. У його тілі ми&nbsp;визначаємо, що&nbsp;має статися під час&nbsp;створення об’єкта. Найчастіше тут ми&nbsp;вказуємо атрибути об’єкта.

```python
class Game:
    def __init__(self):
        print("Starting...")
        self.started = True


game = Game()  # Starting...
print(game.started)  # True
```

Кількість параметрів функції `__init__` визначає, скільки аргументів має входити до виклику конструктора (тобто в&nbsp;дужках, які ми&nbsp;ставимо після назви класу, коли створюємо об’єкт). Отже, якщо у&nbsp;функції `__init__` ми&nbsp;додамо параметр `name`, тоді під час&nbsp;створення об’єкта ми&nbsp;більше не&nbsp;зможемо залишати порожні дужки. Ми&nbsp;повинні вказати там аргумент, який буде назвою. Характерна риса функції `__init__` — це&nbsp;те, що&nbsp;вона очікує певних параметрів, а потім призначає їх об’єкту як&nbsp;атрибути з&nbsp;тими ж назвами.

```python
class User:
    def __init__(self, name):
        self.name = name


user1 = User("Мацєк")
user2 = User("Марта")
print(user1.name)  # Мацєк
print(user2.name)  # Марта
```

Ініціалізатор може містити багато параметрів. Ми&nbsp;можемо використовувати їх як&nbsp;завгодно для визначення атрибутів, хоча найчастіше значення параметрів встановлюються безпосередньо для однойменних атрибутів, як&nbsp;у випадку з&nbsp;`name` і `surname` у&nbsp;прикладі нижче. Значення атрибута `full_name` розраховується на&nbsp;основі `name` і `surname`. Значення `points` визначається як&nbsp;`0`.

```python
class Player:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname
        self.full_name = f"{name} {surname}"
        self.points = 0


player = Player("Міхал", "Мазур")
print(player.name)  # Міхал
print(player.surname)  # Мазур
print(player.full_name)  # Міхал Мазур
print(player.points)  # 0
```

### Вправа: Банківський рахунок

Створи клас, який представляє банківський рахунок. Яка назва класу буде вдалою? Цей клас повинен мати атрибут `balance`, який вказує суму коштів на&nbsp;цьому рахунку. Він також повинен містити методи:

- `deposit`, який додає вказану суму грошей до `balance`,
- `withdraw`, який за достатньої кількості коштів віднімає суму від `balance`, і повертає `True`, а в&nbsp;інакшому випадку — `False`.

```python
account = BankAccount()
print(account.balance)  # 0
account.deposit(1000)
print(account.balance)  # 1000
account.deposit(2000)
print(account.balance)  # 3000
res = account.withdraw(1500)
print(res)  # True
print(account.balance)  # 1500
res = account.withdraw(2000)
print(res)  # False
print(account.balance)  # 1500
```

Крім того, створи два об’єкти, які представляють банківські рахунки, й перевір, чи зміниться баланс одного з&nbsp;них, якщо Ти&nbsp;покладеш або знімеш гроші з&nbsp;іншого.

Відповіді в кінці книги.

## Об’єкти та&nbsp;змінні

Тут я хочу підкреслити, що&nbsp;кожен об’єкт є окремою сутністю. Те, що&nbsp;вони мають схожий вигляд, не&nbsp;означає, що&nbsp;вони впливають одне на&nbsp;одного. Тому в&nbsp;наведеному нижче прикладі змінна `name` в&nbsp;об’єкті `user1` не&nbsp;матиме жодного впливу на&nbsp;`user2`.

```python
class User:
    def __init__(self, name):
        self.name = name


user1 = User("Рафал")
user2 = User("Рафал")

print(user1.name)  # Рафал
print(user2.name)  # Рафал

user1.name = "Бартек"

print(user1.name)  # Бартек
print(user2.name)  # Рафал
```

З іншого боку, якщо у&nbsp;нас є дві змінні, які вказують на&nbsp;один об’єкт, ми&nbsp;можемо змінити його, використовуючи будь-яку з&nbsp;них. Після цього зміняться значення обох змінних, тому що&nbsp;змінилося щось, на&nbsp;що ці дві змінні вказують.

```python
user1 = User("Рафал")
user2 = user1

print(user1.name)
# Рафал
print(user2.name)
# Рафал

user1.name = "Бартек"

print(user1.name)
# Бартек
print(user2.name)
# Бартек
```

{width: 70%}
![Дві змінні вказують на&nbsp;той самий об’єкт, тож властивість цього об’єкта змінює значення.](108_ref_2.png)

Це можна порівняти з&nbsp;прикладом, коли два об’єкти мали однакове значення, а потім змінилося те, на&nbsp;що вказує одна зі змінних. Результат буде іншим.

```python
user1 = User("Рафал")
user2 = user1

print(user1.name)
# Рафал
print(user2.name)
# Рафал

user1 = User("Бартек")

print(user1.name)
# Бартек
print(user2.name)
# Рафал
```

{width: 70%}
![Спочатку дві змінні вказують на&nbsp;той самий об’єкт, потім змінна `user1` починає вказувати на&nbsp;інший.](108_ref_1.png)

## Приватні елементи

У Python є домовленість, що&nbsp;якщо ми&nbsp;не хочемо, щоб атрибути та&nbsp;методи використовувалися поза межами цього класу, їхні назви починаються з&nbsp;символу підкреслення `_`. Такі атрибути та&nbsp;методи ми&nbsp;називаємо *приватними*. Вони повинні використовуватися виключно в&nbsp;інших методах того ж класу.

```python
class BankAccount:
    # ...

    def _validate_user(self, token):
        # ...
        pass

    def make_transaction(self, token, transaction):
        self._validate_user(token)
        # ...
```

Технічно такі елементи всеодно будуть доступні, проте слід уникати їх використання поза класом. Є багато причин робити певні атрибути приватними. Наприклад, у&nbsp;класі `BankAccount` з&nbsp;попередньої вправи ми&nbsp;можемо захотіти стежити, щоб баланс рахунку ніколи не&nbsp;падав нижче нуля. Ми&nbsp;могли би зробити це, зробивши `balance` приватним, а також повертаючи його значення методом `get_balance`, а в&nbsp;методі `withdraw` — контролюючи стан рахунку.

## Атрибути класу

Іноді ми&nbsp;хочемо створити змінну або функцію, яка пов’язана не&nbsp;з&nbsp;об’єктом, а з&nbsp;класом. Іншими словами, вона буде спільною для всіх об’єктів цього класу.

Щоб створити змінну класу, достатньо визначити її&nbsp;в&nbsp;тілі цього класу. Щоб&nbsp;послатися на&nbsp;неї, ми&nbsp;спочатку використовуємо назву класу, потім ставимо крапку, а потім вказуємо назву цієї змінної. Тому не&nbsp;потрібно створювати жодних об’єктів.

```python
class Score:
    points = 0


print(Score.points)  # 0
Score.points = 1
print(Score.points)  # 1
```

Але тут на&nbsp;нас чекає сюрприз. Таким методом ми&nbsp;також можемо запитувати об’єкт, і він поверне своє значення. Є умова: не&nbsp;повинно бути об’єктної змінної з&nbsp;таким же ім’ям. Це означає, що&nbsp;коли у&nbsp;прикладі нижче ми&nbsp;вперше запитуємо `score1.points`, то отримуємо значення змінної класу, а коли вдруге — об’єктну змінну.

```python
class Score:
    points = 0


score1 = Score()
print(score1.points)  # 0
score1.points = 10
print(score1.points)  # 10
```

Однак і тут є пастка. Коли хтось змінить значення змінної класу, усі об’єкти, які не&nbsp;мають об’єктної змінної з&nbsp;такою ж назвою, повертатимуть нові значення.

```python
score1 = Score()
score1.points = 10
score2 = Score()
score3 = Score()
print(score1.points)  # 10
print(score2.points)  # 0
print(score3.points)  # 0
Score.points = 2
print(score1.points)  # 10
print(score2.points)  # 2
print(score3.points)  # 2
```

Іншими словами, якщо ми&nbsp;визначили атрибути з&nbsp;однаковими назвами для класу та&nbsp;об’єкта, тоді першими зчитуватимуться атрибути об’єкта, а якщо їх немає — з&nbsp;класу. Коли після об’єкта ми&nbsp;вказуємо назву змінної та&nbsp;використовуємо символ присвоєння, ми&nbsp;встановлюємо значення об’єктної змінної, а не&nbsp;змінної класу.

Змінні класу часто використовуються для зберігання значень, які не&nbsp;повинні змінюватися. Наприклад, клас, який обчислює розмір податку, може визначатися сталими значеннями податкових ставок.

```python
class TaxCalculator:
    VAT = 0.23
    # ...
```

Зверни увагу, що&nbsp;я використав лише великі літери. У випадку сталих значень, тобто значень, встановлених розробником, які не&nbsp;змінюються, використовуються великі літери, тобто запис, відомий як&nbsp;SCREAMING_SNAKE_CASE.

{width: 60%}
![](SCREAMING_SNAKE_CASE.png)

Іноді утворюються класи виключно для зберігання сталих значень. Наприклад, у&nbsp;третій частині, присвяченій написанню гри "Змійка", нам потрібно буде якимось чином визначити напрямок руху. Для цього ми&nbsp;будемо використовувати клас `Direction` зі змінними, які відповідатимуть за окремі напрямки. Ці змінні можна було б визначити інакше, але такий спосіб забезпечує нам чіткість.

```python
class Direction:
    UP = 1
    DOWN = 2
    LEFT = 3
    RIGHT = 4


# Приклад використання
direction = Direction.UP
if direction == Direction.UP:
    direction = Direction.DOWN
```

Функції, присвоєні класу, а не&nbsp;об’єкту, називаються статичними. Вони визначаються так само, як&nbsp;звичайні методи, але не&nbsp;мають параметра `self`. Ми&nbsp;також повинні ставити перед ними `@staticmethod`. Ми&nbsp;можемо викликати ці методи в&nbsp;класі, вони не&nbsp;потребують об’єкта.

```python
class Counter:
    num = 0

    def __init__(self):
        print("Створюю")
        Counter.num += 1

    @staticmethod
    def print_counter():
        print(f"Створено {Counter.num}")


c1 = Counter()  # Створюю
c2 = Counter()  # Створюю
c3 = Counter()  # Створюю
Counter.print_counter()  # Створено 3
```

## Перевірка класу об’єкта

Щоб перевірити, у&nbsp;якому класі створено об’єкт, ми&nbsp;можемо використовувати функцію `type`, яка повертає об’єкт, що&nbsp;називається типом. Ми&nbsp;вже познайомилися із типами в&nbsp;розділі *Основні значення*, де&nbsp;розглянули `str`, `int`, `float` і `bool`. Назви класів — це&nbsp;також типи, тому ми&nbsp;можемо перевірити, чи об’єкт створено за допомогою класу `Cookie`, порівнюючи його тип із `Cookie`. Типи порівнюються за допомогою слова `is`. Ми&nbsp;вже познайомилися з&nbsp;ним, обговорюючи значення `None` у&nbsp;розділі *Змінні*. Якщо ми&nbsp;хочемо перевірити, чи типи відрізняються одне від одного, ми&nbsp;використовуємо `is not`.

```python
class Cookie:
    pass


c = Cookie()
print(type(c))  # <class ‘__main__.Cookie’>
print(type(c) is Cookie)  # True
print(type(c) is not Cookie)  # False
print(type(c) is int)  # False
print(type(c).__name__)  # Cookie
```

## Клас `str`

У розділі *Основні значення* ми&nbsp;познайомилися з&nbsp;рядками, числовими та&nbsp;логічними значеннями. Вони також є об’єктами, тому мають клас, конструктор і методи. Зосередьмося на&nbsp;класі `str`, який використовується для створення рядків. Назва `str` не&nbsp;дуже типова для класів, але врешті-решт рядок — це&nbsp;особливе значення. Його конструктор дозволяє перетворювати об’єкти іншого типу в&nbsp;об’єкт класу `str`[^201_3].

```python
str1 = "AAA"
print(type(str1))  # <class ‘str’>

i = 10
print(type(i))  # <class ‘int’>
str2 = str(i)
print(type(str2))  # <class ‘str’>
```

```python
b = True
print(type(b))  # <class ‘bool’>
str3 = str(b)
print(type(str3))  # <class ‘str’>
```

Коли ми&nbsp;передаємо функції `print` об’єкт, який має інший тип, ніж `str`, він замінюється за допомогою конструктора. Він також використовується f-рядками, наприклад, у&nbsp;нещодавно використаному `f"Створено {Counter.num}"`.

Клас `str` визначає певні методи, які ми&nbsp;можемо викликати для будь-якого об’єкта типу `str`. Ось найважливіші з&nbsp;них:

* `upper` повертає текст із перетворенням усіх малих літер на&nbsp;великі;
* `lower` повертає текст із перетворенням усіх великих літер на&nbsp;малі;
* `capitalize` повертає текст, у&nbsp;якому перша літера замінюється великою;
* `title` повертає текст, у&nbsp;якому перші літери кожного слова замінюються на&nbsp;великі;
* `replace` повертає текст із заміною всіх повторень одного слова на&nbsp;інше.

```python
name = "dOmInIkA sito"

print(name.upper())  # DOMINIKA SITO
print(name.lower())  # dominika sito
print(name.capitalize())  # Dominika sito
print(name.title())  # Dominika Sito

text = "Привіт, {name}, пишу тобі"
new_text = text.replace("{name}", "Міхал")
print(new_text)  # Привіт, Міхал, пишу тобі
new_text = new_text.replace("тобі", "Тобі")
print(new_text)  # Привіт, Міхал, пишу Тобі
```

### Завершення

У цьому розділі ми&nbsp;познайомилися з&nbsp;класами. Це дуже важлива частина програмування мовою Python, тож класи будуть корисними для нас впродовж всієї книги. А тепер перейдімо до особливого і дуже корисного класу — списку.

[^201_1]: "init" — скорочення від "initialization", тобто "ініціалізатор". На початку та&nbsp;в&nbsp;кінці цієї назви міститься по&nbsp;два підкреслення.
[^201_2]: **Елемент** — це&nbsp;поняття, яке включає класи, змінні та&nbsp;функції.
[^201_3]: Як ми&nbsp;переконаємося в&nbsp;розділі *Оператори*, це&nbsp;робиться за допомогою спеціального методу `__str__`.


