# Організація проєкту та&nbsp;імпортування

Наразі ми&nbsp;зібрали всі наші функції та&nbsp;класи в&nbsp;одному місці: в&nbsp;одному файлі або середовищі REPL. Цей підхід дуже корисний для навчання, але на&nbsp;практиці проєкти можуть мати сотні класів і функцій. Ми&nbsp;не&nbsp;можемо тримати їх усі в&nbsp;одному файлі. Отже в&nbsp;нашому проєкті з’являється тема організації файлів.

## Організація проєкту

Добре впорядкувати проєкт — непросте завдання. Це трохи нагадує прибирання вдома. Якщо все в&nbsp;одному файлі — це&nbsp;ніби безліч речей насипом в&nbsp;одній шафі. Це працює, коли речей небагато. Однак, коли їх з’являється більше, потрібно порозкладати їх у&nbsp;різні шафи та&nbsp;шухляди. Якщо за цим поділом стоїть зрозуміла логіка, знайти речі буде простіше. Якщо ні, цей поділ не&nbsp;буде корисним.

Про організацію проєкту можна писати довго. Існує багато підходів, деякі з&nbsp;них взаємодоповнюються, а інші суперечать один одному. Загалом наша мета полягає у&nbsp;тому, щоб тісно пов’язані елементи були ближче один до одного (в одному файлі чи принаймні в&nbsp;папці), а менш пов’язані — далі один від одного. Наприклад, якщо ми&nbsp;пишемо функцію, яка використовується іншими файлами, але є єдиною, яка використовує іншу функцію, тоді ці дві функції мають бути якомога ближче одна до одної. Найчастіше ми&nbsp;також ділимо проєкт на&nbsp;файли та&nbsp;папки на&nbsp;основі функцій (наприклад, папка `tax` може містити все, що&nbsp;стосується податків), або використання (наприклад, папка `views` може містити всі визначення елементів перегляду, тобто як&nbsp;має виглядати наш застосунок). Якщо над нашим проєктом працюють дві окремі команди, ми&nbsp;прагнемо, щоб вони працювали над різними файлами чи папками.

Коли ми&nbsp;вже розділили проєкт на&nbsp;окремі файли, нам потрібно змусити їх використовувати свої елементи. Без цього ми&nbsp;не зможемо їх розділити. Щоб&nbsp;використовувати елемент, визначений в&nbsp;іншому файлі, ми&nbsp;послуговуємось імпортуванням.

## Імпорт файлу

Уяви, що&nbsp;Ти створюєш калькулятор заробітної платні для своїх співробітників. У нашому проєкті буде два файли:

`salaries.py` — файл, який містить список працівників та&nbsp;їхніхньої заробітної платні. Цей файл створений та&nbsp;ведеться відділом кадрів.
`finance.py` — файл, який містить функції для розрахунку суми виплати, податків і відображення для переказів наприкінці місяця. Цей файл створений і ведеться фінансовим відділом.

Дуже важливо розділити ці файли. Вони певною мірою незалежні, до того ж ведуться різними відділами. Якби вони були одним файлом, це, швидше за все, призвело би до конфліктів, оскільки один відділ вносив би зміни, яких не&nbsp;розумів би інший.

Одночасно `finance.py` потрібно мати доступ до переліку співробітників, щоб мати можливість переглядати їхню заробітну платню. Для цього нам потрібен імпорт, який ми&nbsp;невдовзі представимо. Але почнемо з&nbsp;зовнішнього вигляду файлу `salaries.py`, який ми&nbsp;будемо імпортувати.

```python
# salaries.py
class Person:
    def __init__(self, full_name, salary):
        self.full_name = full_name
        self.salary = salary

    def __str__(self):
        return self.full_name


workers = [
    Person("Aleksander Brown", 3456.78),
    Person("Celina Drozd", 4567.89),
    # ...
]
```

У проєктах Python кожен файл — це&nbsp;модуль, який можна імпортувати в&nbsp;інші файли. Назва цього модуля — це&nbsp;просто назва файлу, в&nbsp;якому він знаходиться (без розширення ".py"). Однак, якби цей файл знаходився у&nbsp;папці, нам довелося б починати з&nbsp;назви папки та&nbsp;поставити після неї крапку (наприклад, якщо у&nbsp;нас є файл `A` в&nbsp;папці `a`, модуль матиме назву `a.A`).

Найпростіший спосіб імпортувати модуль `salaries` (тобто файл `salaries.py`) — вжити слово `import` і назву цього модуля, тобто `import salaries`. В результаті цієї інструкції ми&nbsp;отримуємо об’єкт `salaries`, який містить усі елементи, визначені у&nbsp;файлі `salaries.py`.

```python
import salaries

for person in salaries.workers:
    print(person)
# Aleksander Brown
# Celina Drozd

print(salaries.Person("Ala Mała", 5678))
# Ala Mała
```

Імпортуючи файли, ми&nbsp;можемо посилатися на&nbsp;змінну `workers` і використати її&nbsp;для перегляду списку виплат:

```python
import salaries


def brutto_to_netto(brutto):
    # Дуже спрощена функція
    return brutto * 0.75


if __name__ == '__main__':
    for worker in salaries.workers:
        salary_netto = brutto_to_netto(worker.salary)
        print(f"{salary_netto} для {worker.full_name}")

# 2592.0 для Aleksander Brown
# 3425.25 для Celina Drozd
```

## Імпорт модуля під зміненою назвою

Ми часто хочемо імпортувати модуль, але звертатися до нього під іншою (зазвичай коротшою) назвою. У нашому прикладі `salaries` може бути хорошою назвою для модуля, але не&nbsp;обов’язково для об’єкта, який містить те, що&nbsp;в цьому модулі зберігається. Для працівників фінансового відділу було б інтуїтивно зручно називати цей об’єкт `hr`, тому що&nbsp;всі говорять, що&nbsp;це&nbsp;дані з&nbsp;відділу HR [^205_1]. Щоб&nbsp;зробити це, ми&nbsp;можемо додати ключове слово `as`, яке вказує, під якою назвою має відображатися імпортований об’єкт. Цей спосіб імпортування дуже популярний, оскільки він не&nbsp;лише чітко показує, звідки походять елементи, але й скорочує посилання на&nbsp;них.

```python
import salaries as hr


for person in hr.workers:
    print(person)
# Aleksander Brown
# Celina Drozd
print(hr.Person("Ala Mała", 5678))
# Ala Mała
```

Змінімо наш код для розрахунку сум виплат:

```python
import salaries as hr


def brutto_to_netto(brutto):
    # Дуже спрощена функція
    return brutto * 0.75


if __name__ == '__main__':
    for worker in hr.workers:
        salary_netto = brutto_to_netto(worker.salary)
        print(f"{salary_netto} для {worker.full_name}")

# 2592.0 для Aleksander Brown
# 3425.25 для Celina Drozd
```

## Імпорт елемента з&nbsp;модуля

Замість того, щоб імпортувати весь модуль, ми&nbsp;можемо імпортувати з&nbsp;нього лише один елемент. У цьому випадку ми&nbsp;починаємо зі слова `from`, потім вказуємо назву модуля, використовуємо слово `import` і зазначаємо назву елемента, який потрібно імпортувати. Ось як&nbsp;буде виглядати імпорт класу `Person`:

```python
from salaries import Person

print(Person("Ala Mała", 5678))
# Ala Mała
```

Ось як&nbsp;виглядатиме імпорт змінної `workers`:

```python
from salaries import workers

for person in workers:
    print(person)
# Aleksander Brown
# Celina Drozd
```

Ось як&nbsp;виглядатиме наш модуль після імпорту `workers`:

```python
from salaries import workers


def calculate_salary(brutto):
    # Дуже спрощена функція
    return brutto * 0.75


if __name__ == '__main__':
    for worker in workers:
        salary_netto = calculate_salary(worker.salary)
        print(f"{salary_netto} для {worker.full_name}")

# 2592.0 для Aleksander Brown
# 3425.25 для Celina Drozd
```

Завдяки імпорту елемента `workers` ми&nbsp;можемо посилатися на&nbsp;нього без указування назви модуля.

## Імпорт пакетів

Для різних проєктів часто потрібні подібні класи та&nbsp;функції. Щоб&nbsp;не&nbsp;писати їх знову і знову, була створена концепція пакетів [^205_2]. Пакет — це&nbsp;код, написаний найчастіше зовсім іншим розробником, який ми&nbsp;прикріплюємо до нашого проєкту. Існує багато розробників пакетів. Вони створюють та&nbsp;розвивають їх, а потім розміщують в&nbsp;інтернеті, щоб ми&nbsp;могли легко ними користуватися.

Python має дуже хорошу підтримку надання пакетів у&nbsp;користування іншим розробникам. Завдяки цьому в&nbsp;ньому можна кількома рядками коду виконати великий об’єм роботи. Кілька хороших прикладів буде показано в&nbsp;четвертій частині, де&nbsp;ми&nbsp;побачимо, як&nbsp;завдяки коду всього на&nbsp;кілька лінійок із використанням пакета можна навчити штучний інтелект розпізнавати рукописний текст. Встановленню зовнішніх пакетів присвячений наступний розділ. Наразі, щоб побачити, як&nbsp;імпортувати з&nbsp;них елементи, ми&nbsp;скористаємося пакетами, які встановлюються разом з&nbsp;Python.

{width: 80%}
![](funny_profesor_essey.png)

Для початку ми&nbsp;можемо, наприклад, використати пакет `math`, який містить різноманітні математичні функції. До&nbsp;нього входить, наприклад функція `factorial`, яку ми&nbsp;самі реалізували в&nbsp;розділі *Функції*. Щоб&nbsp;імпортувати пакет, замість назви файлу ми&nbsp;використовуємо назву цього пакета.

```python
import math

print(math.factorial(5))  # 120
```

Ще один приклад — `sin`, тобто синус, дуже важлива в&nbsp;математиці функція. Замість того, щоб імпортувати весь пакет, ми&nbsp;імпортуємо лише функцію `sin` через `from math import sin`.

```python
from math import sin

print(sin(2.3))  # 0.7457052121767203
```

Іншим прикладом є пакет `random`, який надає функції, що&nbsp;повертають випадкові значення. Наприклад, якщо ми&nbsp;використовуємо функцію `randit`, визначену в&nbsp;цьому пакеті, ми&nbsp;отримаємо випадкове ціле число в&nbsp;заданому діапазоні.

```python
import random

print(random.randint(1, 10))
# Випадкове число від 1 до 10 (включно з 10)
```

Функції з&nbsp;`random` широко використовуються в&nbsp;різноманітних азартних іграх. Коли хтось проводить вікторину, він може використовувати функцію `shuffle`, щоб перетасувати запитання. Особливо популярна функція `random`, яка повертає дійсне число більше, ніж 0, але менше, ніж 1.

```python
from random import random

print(random())
# Число, яке більше, ніж 0, або дорівнює 0, 
# але менше, ніж 1
```

Нарешті, погляньмо на&nbsp;пакет `datetime`. Він дозволяє нам працювати з&nbsp;часом, часовими поясами, датами тощо. Клас `datetime`, що&nbsp;в ньому міститься, визначає дату. Якщо ми&nbsp;хочемо визначити, які зараз дата й час&nbsp;(на основі часу нашого комп’ютера), ми&nbsp;можемо використовувати `datetime.now()`. Об’єкт `datetime` має, серед іншого, атрибути `year`, `month` та&nbsp;`day`, які дозволяють посилатися на&nbsp;певний компонент дати.

```python
from datetime import datetime

battle = datetime(1410, 7, 15)
print(battle)  # 1410-07-15 00:00:00
print(battle.year)  # 1410
print(battle.month)  # 7
print(battle.day)  # 15

now = datetime.now()
print(now)  # np. 2022-02-02 12:23:17.058498
```

Велика кількість пакетів і простота їх використання є сильними сторонами мови Python. Не сумніваюся, що&nbsp;Ти ще не&nbsp;раз у&nbsp;цьому пересвідчишся.

[^205_1]: HR — скорочення від англ. "Human Resources", інакше кажучи, відділ кадрів.
[^205_2]: Концепція пакета використовується подібно, як&nbsp;і в&nbsp;багатьох інших мовах програмування, — ідея **бібліотек**. Іноді ці два терміни вважаються взаємозамінними, але в&nbsp;Python більше прийнято вживати термін "пакет".

